<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HEXCARB</title>
  <meta name="description" content="HexCarb — SWCNT fibers, dispersions, and smart textiles accelerated by the HEXCARB AI Engine. Forging the future, atom by atom.">
  <link rel="canonical" href="https://www.hexcarb.in/">
  <meta property="og:title" content="HEXCARB">
  <meta property="og:description" content="SWCNT fibers, dispersions, and smart textiles — accelerated by the HEXCARB AI Engine.">
  <meta property="og:type" content="website">

  <!-- Tailwind (for layout only) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />

  <style>
    html { scroll-behavior: smooth; }
    body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; transition: background .3s, color .3s; }
    .fade-in { opacity: 0; transform: translateY(20px); animation: fadeInUp .8s ease-out forwards; }
    @keyframes fadeInUp { to { opacity:1; transform: translateY(0); } }

    .floating-inbox {
      position: fixed; bottom: 20px; right: 20px; z-index: 1000;
      background: #fff; padding: 12px; border: 2px solid #000; border-radius: 50%;
      box-shadow: 0 0 10px rgba(0,0,0,.15); transition: transform .3s ease, box-shadow .3s ease;
    }
    .floating-inbox:hover { transform: scale(1.08); box-shadow: 0 0 20px rgba(0,0,0,.25); }
    .dark .floating-inbox { background:#111; border-color:#fff; }

    /* ===== Engine visuals ===== */
    #engineOverlay .node-lit circle { fill:#fff !important; filter:url(#glow); }
    .wire { fill:none; stroke-linecap:round; stroke-linejoin:round; }
    .light { stroke:#fff; filter:url(#glow); }

    /* Right-hemisphere takeover sheen (percentage width; viewBox 0..100) */
    @keyframes takeoverSweep { 0% { width:0; opacity:.10 } 60%{ width:32; opacity:.20 } 100%{ width:52; opacity:.16 } }
    #takeover.sweep { animation: takeoverSweep 920ms ease-out forwards; }

    /* Left warm glow */
    @keyframes warmUp { 0%{opacity:0;r:10} 40%{opacity:.22;r:18} 100%{opacity:.12;r:22} }
    #warmGlow.run { animation: warmUp 600ms ease-out forwards; }

    /* Impulse dots + Mapper helpers */
    .impulse-dot { fill:#fff; filter:url(#glow); opacity:.95 }
    .map-guide { stroke:#ffffffaa; stroke-dasharray:2 2; fill:none; }
    .map-point { fill:#ffffff99; }
    .map-hint { position:absolute; right:14px; bottom:14px; font-size:12px; opacity:.65; background:rgba(0,0,0,.45); color:white; padding:6px 10px; border-radius:8px; }
    .dark .map-hint { background:rgba(255,255,255,.1) }

    @media (prefers-reduced-motion: reduce) {
      #engineOverlay * { transition:none !important; animation:none !important; }
    }
  </style>
</head>
<body class="bg-white text-black dark:bg-black dark:text-white">

  <!-- Simple header -->
  <header class="sticky top-0 z-40 bg-white/90 dark:bg-black/80 backdrop-blur border-b border-black/10 dark:border-white/10">
    <nav class="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between">
      <div class="text-xl font-extrabold tracking-wide">HexCarb</div>
      <a href="https://ai.hexcarb.in" class="inline-block bg-black text-white dark:bg-white dark:text-black px-4 py-2 rounded hover:opacity-90 transition" target="_blank" rel="noopener">HEXCARB AI Engine</a>
    </nav>
  </header>

  <!-- Hero (kept minimal) -->
  <section class="relative text-center py-14 px-6 fade-in bg-cover bg-center bg-no-repeat" style="background-image:url('1.png');">
    <div class="absolute inset-0 bg-black/50 backdrop-blur-sm z-0"></div>
    <div class="relative z-10">
      <img src="logo.svg" alt="HEXCARB Logo" class="mx-auto mb-6 object-contain drop-shadow-[0_0_15px_rgba(255,255,255,0.9)]" />
      <h1 class="text-4xl font-extrabold mb-2 tracking-wide text-white drop-shadow-md">HexCarb</h1>
      <p class="text-lg max-w-xl mx-auto text-white/95">Forging the future atom by atom.</p>
    </div>
  </section>

  <!-- ========= HEXCARB AI ENGINE — PANEL ========= -->
  <section id="engine" class="relative px-4 py-10 md:py-14">
    <div class="max-w-7xl mx-auto bg-white dark:bg-black rounded-3xl border border-black/10 dark:border-white/10 shadow-[0_12px_60px_rgba(0,0,0,0.12)] dark:shadow-[0_12px_60px_rgba(0,0,0,0.45)] overflow-hidden">

      <div class="px-6 sm:px-10 pt-8 pb-2 text-center">
        <h2 class="text-4xl md:text-5xl font-extrabold tracking-tight">HEXCARB — Science-Tech Hybrid Engine</h2>
        <p class="mt-3 text-lg md:text-xl text-gray-700 dark:text-gray-300">Science that thinks. Technology that invents.</p>
      </div>

      <!-- Click target -->
      <button id="engineStart" class="group relative block w-full text-left focus:outline-none" aria-label="Start HEXCARB AI Engine">
        <!-- Brain image (slightly reduced width for breathing room) -->
        <div class="w-full flex justify-center">
          <img id="brainImg" src="3.png" alt="HEXCARB hybrid brain — AI nodes and CNT lattice" class="w-[92%] h-auto select-none pointer-events-none">
        </div>

        <!-- SVG overlay -->
        <svg id="engineOverlay" viewBox="0 0 100 100" class="absolute inset-0 w-full h-full pointer-events-none" aria-hidden="true">
          <defs>
            <filter id="glow"><feGaussianBlur stdDeviation="1.8" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
            <linearGradient id="sweep" x1="0" y1="0" x2="1" y2="0">
              <stop offset="0%" stop-color="white" stop-opacity="0"/>
              <stop offset="50%" stop-color="white" stop-opacity="0.25"/>
              <stop offset="100%" stop-color="white" stop-opacity="0"/>
            </linearGradient>
            <!-- Right hemisphere mask (adjust if your composition differs) -->
            <mask id="rightMask" maskUnits="objectBoundingBox">
              <rect x="0.50" y="0.10" width="0.48" height="0.80" fill="white"/>
            </mask>
          </defs>

          <!-- Warm glow (left) -->
          <circle id="warmGlow" cx="30" cy="50" r="10" fill="white" opacity="0"/>

          <!-- Mapped animated paths are appended here -->
          <g id="mapPaths" class="light" stroke-width="1.35"></g>

          <!-- Right-side sheen sweep -->
          <g mask="url(#rightMask)">
            <rect id="takeover" x="50" y="0" width="0" height="100" fill="url(#sweep)" />
          </g>

          <!-- Exit pulse -->
          <circle id="exitPulse" cx="94" cy="69" r="0.8" fill="#fff" opacity="0"/>

          <!-- Mapper helpers -->
          <g id="mapGuide" class="map-guide" visibility="hidden"></g>
          <g id="mapPoints" visibility="hidden"></g>
        </svg>

        <!-- Map hint UI -->
        <div id="mapHint" class="map-hint hidden">
          Map Mode • M toggle · L/B/R/T choose segment · Click to add points · Enter finish · Backspace undo · Esc cancel · G ridge-snap · C curve on/off · S save
        </div>

        <div class="px-6 sm:px-10 pb-8 pt-4 flex items-center justify-between flex-wrap gap-3">
          <div class="text-sm text-gray-700 dark:text-gray-300">
            Click to ignite the engine → neural impulses traverse the structure → enter the live system.
          </div>
          <div class="flex items-center gap-3 text-sm">
            <span class="opacity-70">HEXCARB AI Engine</span>
            <span class="inline-block w-2 h-2 rounded-full bg-black dark:bg-white animate-ping"></span>
          </div>
        </div>
      </button>
    </div>
  </section>

  <!-- Footer -->
  <footer class="bg-white dark:bg-black text-gray-400 py-6 text-center text-sm border-t border-black/10 dark:border-white/10">
    <p>&copy; 2025 HexCarb Advanced Materials Private Limited</p>
  </footer>

  <!-- Floating Inbox -->
  <a href="mailto:info@hexcarb.in" class="floating-inbox" aria-label="Get in Touch">
    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4 4h16v16H4z"/><polyline points="22,6 12,13 2,6" />
    </svg>
  </a>

  <!-- Hidden canvas for ridge-snap sampling -->
  <canvas id="sampleCanvas" style="position:fixed; left:-9999px; top:-9999px;" width="1" height="1"></canvas>

  <script>
  (function(){
    const btn   = document.getElementById('engineStart');
    const img   = document.getElementById('brainImg');
    const svg   = document.getElementById('engineOverlay');
    const mapPaths  = svg.getElementById('mapPaths');
    const mapGuide  = svg.getElementById('mapGuide');
    const mapPoints = svg.getElementById('mapPoints');
    const warmGlow  = svg.getElementById('warmGlow');
    const takeover  = svg.getElementById('takeover');
    const exitPulse = svg.getElementById('exitPulse');
    const hintBox   = document.getElementById('mapHint');

    const canvas = document.getElementById('sampleCanvas');
    const ctx = canvas.getContext('2d');

    /* ---------- Mapper state ---------- */
    const MAP = {
      on:false, type:'L', curve:true, ridge:true,
      current:[], counter:{L:0,B:0,R:0,T:0}, saved:{ L:[], B:[], R:[], T:[] }
    };

    function toggleMap(on){
      MAP.on = (on ?? !MAP.on);
      mapGuide.setAttribute('visibility', MAP.on?'visible':'hidden');
      mapPoints.setAttribute('visibility', MAP.on?'visible':'hidden');
      hintBox.classList.toggle('hidden', !MAP.on);
      svg.style.pointerEvents = MAP.on ? 'auto' : 'none';
      if (MAP.on) drawToCanvas(); // prepare sampling
    }
    function setType(t){ MAP.type = t; }
    function toggleCurve(){ MAP.curve = !MAP.curve; showHint(); }
    function toggleRidge(){ MAP.ridge = !MAP.ridge; showHint(); }

    function showHint(){
      hintBox.textContent =
        'Map Mode • M toggle · L/B/R/T choose segment · Click to add points · Enter finish · Backspace undo · Esc cancel · ' +
        'G ridge-snap ['+(MAP.ridge?'ON':'OFF')+'] · C curve ['+(MAP.curve?'ON':'OFF')+'] · S save';
    }

    /* ---------- Coordinate helpers ---------- */
    function clientToViewBox(clientX, clientY){
      const pt = svg.createSVGPoint(); pt.x = clientX; pt.y = clientY;
      const inv = svg.getScreenCTM().inverse();
      const loc = pt.matrixTransform(inv);
      return [ +(loc.x).toFixed(1), +(loc.y).toFixed(1) ];
    }

    function viewBoxToImgPixels(vx, vy){
      // Convert 0..100 viewBox into page pixels and then into canvas pixels
      const svgRect = svg.getBoundingClientRect();
      const pageX = svgRect.left + (vx/100)*svgRect.width;
      const pageY = svgRect.top  + (vy/100)*svgRect.height;

      const imgRect = img.getBoundingClientRect();
      // Return coordinates inside the canvas where we drew the image
      // Canvas is sized to the page (for simplicity) and image is drawn at its page rect.
      const x = pageX;
      const y = pageY;
      return [x,y];
    }

    /* ---------- Canvas sampling (ridge-snap) ---------- */
    function drawToCanvas(){
      // draw full page-sized canvas and paint the image at its on-page rect
      const w = Math.max(1, Math.ceil(window.innerWidth));
      const h = Math.max(1, Math.ceil(window.innerHeight));
      canvas.width = w; canvas.height = h;
      ctx.clearRect(0,0,w,h);

      const r = img.getBoundingClientRect();
      try {
        ctx.drawImage(img, r.left, r.top, r.width, r.height);
      } catch(e) {
        // Cross-origin? It will fail; we just skip ridge-snap gracefully.
      }
    }
    window.addEventListener('resize', ()=>{ if (MAP.on) drawToCanvas(); });

    function luminanceAtPage(px, py){
      try {
        const d = ctx.getImageData(Math.floor(px), Math.floor(py), 1, 1).data;
        // simple luma
        return 0.2126*d[0] + 0.7152*d[1] + 0.0722*d[2];
      } catch(e) { return 255; }
    }

    function ridgeSnapPoint(vx, vy){
      if (!MAP.ridge) return [vx,vy];
      // search small neighborhood (page pixels) for darkest point (ridge)
      const [baseX, baseY] = viewBoxToImgPixels(vx, vy);
      const R = 8; // px radius
      let best = {L: 1e9, x: baseX, y: baseY};
      for (let dy=-R; dy<=R; dy++){
        for (let dx=-R; dx<=R; dx++){
          const L = luminanceAtPage(baseX+dx, baseY+dy);
          if (L < best.L){ best = {L, x: baseX+dx, y: baseY+dy}; }
        }
      }
      // convert back from page px to viewBox
      const svgRect = svg.getBoundingClientRect();
      const vx2 = Math.max(0, Math.min(100, ((best.x - svgRect.left)/svgRect.width)*100));
      const vy2 = Math.max(0, Math.min(100, ((best.y - svgRect.top )/svgRect.height)*100));
      return [ +vx2.toFixed(1), +vy2.toFixed(1) ];
    }

    /* ---------- Bézier smoothing (Catmull–Rom to Cubic) ---------- */
    function catmullRom2bezier(points){
      if (points.length < 2) return '';
      if (!MAP.curve || points.length === 2){
        return 'M ' + points.map(p=>p.join(',')).join(' L ');
      }
      const p = points.map(pt => ({x:pt[0], y:pt[1]}));
      let d = `M ${p[0].x},${p[0].y}`;
      for (let i=0; i<p.length-1; i++){
        const p0 = i>0 ? p[i-1] : p[i];
        const p1 = p[i];
        const p2 = p[i+1];
        const p3 = i !== p.length-2 ? p[i+2] : p2;
        const cp1x = p1.x + (p2.x - p0.x)/6;
        const cp1y = p1.y + (p2.y - p0.y)/6;
        const cp2x = p2.x - (p3.x - p1.x)/6;
        const cp2y = p2.y - (p3.y - p1.y)/6;
        d += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${p2.x},${p2.y}`;
      }
      return d;
    }

    /* ---------- Mapper UI ---------- */
    function redrawGuide(){
      const d = MAP.current.length ? 'M '+MAP.current.map(p=>p.join(',')).join(' L ') : '';
      mapGuide.innerHTML = '';
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', d);
      mapGuide.appendChild(p);
      mapPoints.innerHTML = '';
      MAP.current.forEach(([x,y])=>{
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('cx',x); c.setAttribute('cy',y); c.setAttribute('r',.8);
        c.setAttribute('class','map-point'); mapPoints.appendChild(c);
      });
    }

    function addPoint(evt){
      const [vx, vy] = clientToViewBox(evt.clientX, evt.clientY);
      const [sx, sy] = ridgeSnapPoint(vx, vy);
      MAP.current.push([sx, sy]);
      redrawGuide();
    }

    function finishPath(){
      if (MAP.current.length < 2) return;
      const id = `map-${MAP.type}-${++MAP.counter[MAP.type]}`;
      const d = catmullRom2bezier(MAP.current);
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('id', id);
      path.setAttribute('class','wire light');
      path.setAttribute('d', d);
      path.setAttribute('stroke-width','1.35');
      mapPaths.appendChild(path);
      MAP.saved[MAP.type].push(id);
      MAP.current = [];
      redrawGuide();
      console.log('Saved path:', {id, type:MAP.type, d});
      navigator.clipboard?.writeText(JSON.stringify({id, type:MAP.type, d})).catch(()=>{});
    }

    function undoPoint(){ MAP.current.pop(); redrawGuide(); }

    // Keyboard controls
    window.addEventListener('keydown', (e)=>{
      if (e.key.toLowerCase() === 'm'){ toggleMap(); showHint(); }
      if (!MAP.on) return;
      const k = e.key.toLowerCase();
      if ('lbrt'.includes(k)) setType(k.toUpperCase());
      if (k==='c') toggleCurve();
      if (k==='g') toggleRidge();
      if (e.key === 'Enter') finishPath();
      if (e.key === 'Backspace'){ e.preventDefault(); undoPoint(); }
      if (e.key === 'Escape'){ MAP.current = []; redrawGuide(); }
      if (k==='s'){
        console.log('All paths:', MAP.saved);
        navigator.clipboard?.writeText(JSON.stringify(MAP.saved)).catch(()=>{});
      }
    });
    svg.addEventListener('click', (e)=>{ if (MAP.on) addPoint(e); });

    /* ---------- Impulse engine ---------- */
    function preparePath(p){
      const len = p.getTotalLength();
      p.style.strokeDasharray = len;
      p.style.strokeDashoffset = len;
      return len;
    }
    function animateStroke(p, duration=300, delay=0, easing='ease'){
      return new Promise(resolve=>{
        p.style.transition='none'; void p.getBoundingClientRect();
        p.style.transition = `stroke-dashoffset ${duration}ms ${easing} ${delay}ms`;
        p.style.strokeDashoffset = '0';
        setTimeout(resolve, delay+duration);
      });
    }
    function spawnImpulses(path, {n=6, dur=700, stagger=90, radius=.45, accel=false}={}){
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      svg.appendChild(g);
      const len = path.getTotalLength();
      for (let i=0;i<n;i++){
        const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
        dot.setAttribute('r', radius); dot.setAttribute('class','impulse-dot'); g.appendChild(dot);
        const start = performance.now() + i*stagger;
        const ease = accel ? (t)=>t*t*(3-2*t) : (t)=>t;
        (function move(now){
          const t = Math.min(1, (now - start)/dur);
          if (t<=0){ requestAnimationFrame(move); return; }
          const d = ease(t);
          const pt = path.getPointAtLength(d*len);
          dot.setAttribute('cx', pt.x); dot.setAttribute('cy', pt.y);
          if (t<1) requestAnimationFrame(move); else g.removeChild(dot);
        })(performance.now());
      }
    }
    function pulseExit(){
      exitPulse.style.transition = 'opacity 100ms ease, r 240ms cubic-bezier(.2,.7,.2,1)';
      exitPulse.setAttribute('opacity','1');
      exitPulse.setAttribute('r','2.8');
      setTimeout(()=> exitPulse.setAttribute('opacity','0'), 260);
    }
    function playChime(){
      try {
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const o=ctx.createOscillator(), g=ctx.createGain();
        o.type='sine'; o.frequency.value=760; g.gain.value=.14; o.connect(g); g.connect(ctx.destination);
        o.start(); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+.2); o.stop(ctx.currentTime+.22);
      } catch(_) {}
    }

    function runSequence(){
      const any = [...mapPaths.querySelectorAll('path')];
      if (!any.length || window.matchMedia('(prefers-reduced-motion: reduce)').matches){
        window.location.href='https://ai.hexcarb.in'; return;
      }
      warmGlow.classList.add('run');
      any.forEach(preparePath);

      // Order: L -> B -> R -> T
      const L = MAP.saved.L.map(id=>svg.getElementById(id));
      const B = MAP.saved.B.map(id=>svg.getElementById(id));
      const R = MAP.saved.R.map(id=>svg.getElementById(id));
      const T = MAP.saved.T.map(id=>svg.getElementById(id));

      (async function(){
        for (const p of L){ spawnImpulses(p,{n:7,dur:600,stagger:80,radius:.45}); await animateStroke(p,320,0,'ease-out'); }
        for (const p of B){ spawnImpulses(p,{n:4,dur:380,stagger:70,radius:.5});   await animateStroke(p,240,80,'cubic-bezier(.2,.8,.2,1)'); }
        for (const p of R){ spawnImpulses(p,{n:6,dur:560,stagger:90,radius:.45}); await animateStroke(p,560,60,'cubic-bezier(.2,.85,.2,1)'); }
        takeover.classList.add('sweep');
        for (const p of T){ spawnImpulses(p,{n:6,dur:520,stagger:70,radius:.5,accel:true}); await animateStroke(p,520,40,'cubic-bezier(.1,.95,.2,1)'); }

        pulseExit(); playChime();
        setTimeout(()=>window.location.href='https://ai.hexcarb.in', 260);
      })();
    }

    // Click to start (ignore clicks during map mode)
    btn.addEventListener('click', ()=>{
      if (MAP.on) return;
      btn.disabled = true;
      runSequence();
      setTimeout(()=>{ btn.disabled = false; }, 1500); // allow re-run during testing
    });

    // Ensure canvas is ready after image loads
    if (img.complete) { /* ok */ } else { img.addEventListener('load', ()=>{ if (MAP.on) drawToCanvas(); }); }
  })();
  </script>
</body>
</html>
